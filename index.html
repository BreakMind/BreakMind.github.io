<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Talk is cheap, show me the code.</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="Talk is cheap, show me the code.">
<meta property="og:url" content="http://BreakMind.github.io/index.html">
<meta property="og:site_name" content="Talk is cheap, show me the code.">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Talk is cheap, show me the code.">
  
    <link rel="alternate" href="/atom.xml" title="Talk is cheap, show me the code." type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
  

</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Talk is cheap, show me the code.</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">主页</a>
        
          <a class="main-nav-link" href="/archives">归档</a>
        
          <a class="main-nav-link" href="/">个人简介</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="搜索"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" results="0" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://BreakMind.github.io"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-第5条：用枚举表示状态、选项、状态码" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/03/02/第5条：用枚举表示状态、选项、状态码/" class="article-date">
  <time datetime="2017-03-02T15:50:32.000Z" itemprop="datePublished">2017-03-02</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/IOS-编写高质量代码/">IOS-编写高质量代码</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/03/02/第5条：用枚举表示状态、选项、状态码/">第5条：用枚举表示状态、选项、状态码</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>由于Objective-C基于C语言，所以C语言有的功能它都有。其中之一就是枚举类型：enum。系统框架中频繁用到此类型，然而开发者容易忽视它。在以一系列常量来表示错误状态码或可组合的选项时，极宜使用枚举为其命名。由于C++11标注扩充了枚举的特性，所以最新版本系统框架使用了“强类型”（strong type）的枚举。没错，Objective-C也得益于C++11标准。<br>枚举只是一种常量命名方式。某个对象所经历的各种状态就可以定义为一个简单的枚举集（enumeration set）。比如说，可以用下列枚举表示“套接字链接”（socket connection）的状态：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">enum EOCConnectionState&#123;</div><div class="line">	EOCConnectionStateDisconnected,</div><div class="line">	EOCConnectionStateConnecting,</div><div class="line">	EOCConnectionStateConnected,</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>由于每种状态都用一个便于理解的值来表示，所以这样写出来的代码更易读懂。编译器会为枚举分配一个独有的编号，从0开始，每个枚举值递增为1.实现枚举所用的数据类型取决于编译器。不过其二进制位（bit）的个数必须能完全表示下枚举编号才行。在前例中，由于最大编号是2，所以使用1个字节的char类型即可。<br>然而定义枚举变量的方式却不太简洁，要依如下语法编写：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">enum EOCConnectionState state = EOCConnectionStateDisconnected;</div></pre></td></tr></table></figure></p>
<p>若是每次不用敲入enum而只需写EOCConnectionState就好了。要想这样做，则需使用typedef关键字重新定义枚举类型<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">enum EOCConnectionState&#123;</div><div class="line">	EOCConnectionStateDisconnected = 0,</div><div class="line">	EOCConnectionStateConnecting,</div><div class="line">	EOCConnectionStateConnected,</div><div class="line">&#125;;</div><div class="line">typedef enum EOCConnectionState EOCConnectionState;</div></pre></td></tr></table></figure></p>
<p>也可以简略写<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">typedef enum EOCConnectionState&#123;</div><div class="line">	EOCConnectionStateDisconnected = 0,</div><div class="line">	EOCConnectionStateConnecting,</div><div class="line">	EOCConnectionStateConnected,</div><div class="line">&#125;EOCConnectionState;</div></pre></td></tr></table></figure></p>
<p>现在可以用简写的EOCConnectionState来代替完整的enum EOCConnectionState了：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">EOCConnectionState state = EOCConnectionStateDisconnected;</div></pre></td></tr></table></figure></p>
<p>C++标准修订了枚举的某些特性。其中一项改动是：可以指明用何种“底层数据类型”（underlying type）来保存枚举类型的变量。这样做的好处是，可以向前声明枚举变量了。若不指定底层数据类型，则无法向前声明枚举类型，因为编译器不清楚底层数据类型的大小，所以在用到此枚举类型时，也就不知道究竟该给变量分配多少空间。<br>指定底层数据类型所用的语法是：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">enum EOCConnectionStateConnectionState : NSInteger &#123; /* ... */ &#125;;</div></pre></td></tr></table></figure></p>
<p>上面这行代码确保枚举的底层数据类型是NSInteger。也可以在向前声明时指定底层数据类型：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">enum EOCConnectionStateConnectionState : NSInteger;</div></pre></td></tr></table></figure></p>
<p>还可以不使用编译器所分配的序号，而是手工指定某个枚举成员所对应的值。语法如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">enum EOCConnectionStateConnectionState&#123;</div><div class="line">	EOCConnectionStateDisconnected = 1,</div><div class="line">	EOCConnectionStateConnecting,</div><div class="line">	EOCConnectionStateConnected,</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>上述代码把EOCConnectionStateDisconnected的值设为1，而不使用编译器所分配的0。如前所述，接下来几个枚举的值都会在上一个的基础上递增1。比如说，EOCConnectionStateConnected的值就是3。<br>还有一种情况应该使用枚举类型，那就是定义选项的时候。若这些选项可以彼此组合，则更应如此。只要枚举定义得对，个选项之间就可通过“按位或操作符”（bitwise OR operator）来组合。例如，IOS UI框架中有如下的枚举类型，用来表示某个视图应该如何在水平或垂直方向上调整大小：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">enum UIViewAutoresizing &#123;</div><div class="line">	UIViewAutoresizingNozne				= 0,</div><div class="line">	UIViewAutoresizingFlexibleLeftMargin		= 1 &lt;&lt; 0,</div><div class="line">	UIViewAutoresizingFlexibleWidth			= 1 &lt;&lt; 1,</div><div class="line">	UIViewAutoresizingFlexibleRightMargin		= 1 &lt;&lt; 2,</div><div class="line">	UIViewAutoresizingFlexibleTopMargin		= 1 &lt;&lt; 3,</div><div class="line">	UIViewAutoresizingFlexibleHeight		= 1 &lt;&lt; 4,</div><div class="line">	UIViewAutoresizingFlexibleBottomMargin		= 1 &lt;&lt; 5,</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>每个选项均可开启或禁用，使用上述方式来定义枚举值即可保证这一点，因为在每个枚举值所对应的二进制表示中，只有1个二进制位的值是1。用“按位或操作符”可组合多个选项，例如：UIViewAutoResizingFlexibleWidth | UIViewAutoresizingFlexibleHeight。图1-2列出了每个枚举成员的二进制值，并演示了刚才那两个枚举组合之后的值。用“按位与操作符”（bitwise AND operator）即可判断出是否已启用某个选项：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">enum UIViewAutoresizing resizing = </div><div class="line">	UIViewAutoresizingFlexibleWidth |</div><div class="line">	UIViewAutoresizingFlexibleHeight ;</div><div class="line"></div><div class="line">if (resizing &amp; UIViewAutoresizingFlexibleWidth) &#123;</div><div class="line">	// UIViewAutoresizingFlexibleWidht is set</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<pre><code>图1-2 每个枚举值的二进制表示，以及对其中两个枚举值执行按位或操作之后的二进制值
</code></pre><p>系统库中频繁使用这个办法。 IOS UI框架中的UIKit里还有个例子，用枚举值告诉系统视图所支持的设备显示方向。这个枚举类型叫做UIInterfaceOrientationMask，开发者需要实现一个名为supportedInterfaceOrientations的方法，将视图所支持的显示方向告诉系统：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">- (NSUInteger)supportedInterfaceOrientations &#123;</div><div class="line">	return UIInterfaceOrientationMaskPortrait | UIInterfaceOrientationMaskLandscapeLeft;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>Foundation框架中定义了一些辅助的宏，用这些红来定义枚举类型时，也可以指定用于保存枚举值得底层数据类型。这些宏具备向后兼容（backward compatibility）能力，如果目标平台的编译器支持新标注，那就使用新式语法，否则改用旧式鱍。这些宏是用#define预处理指令来定义的，其中一个用于定义像EOCConnectionState这种普通的枚举类型，另一个定义像UIViewAutoresizing这种包含一系列选项的枚举类型，其用法如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">typedef NS_ENUM(NSUInteger, EOCConnectionState) &#123;</div><div class="line">	EOCConnectionStateDisconnected,</div><div class="line">	EOCConnectionStateConnecting,</div><div class="line">	EOCConnectionStateConnected,</div><div class="line">&#125;;</div><div class="line"></div><div class="line">typedef NS_OPTIONS(NSUinteger, EOCPermittedDirection)&#123;</div><div class="line">	EOCPermittedDirectionUp		= 1 &lt;&lt; 0,</div><div class="line">	EOCPermittedDirectionDown	= 1 &lt;&lt; 1,</div><div class="line">	EOCPermittedDirectionLeft	= 1 &lt;&lt; 2,</div><div class="line">	EOCPermittedDirectionRight	= 1 &lt;&lt; 3,</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>这些宏的定义如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">#if (__cplusplus &amp;&amp; __cplusplus &gt;= 201103L &amp;&amp; (__has_extension(cxx_strong_enums) || _has_feature(objc_fixed_enum))</div><div class="line">	)||</div><div class="line">    (!__cplusplus &amp;&amp; __has_feature(objc_fixed_enum))</div><div class="line">    #define NS_ENUM(_type, _name)</div><div class="line">		enum _name : _type _name; enum _name : type</div><div class="line">    #if (__cplusplus)</div><div class="line">	#define NS_OPTIONS(_type, _name)</div><div class="line">		type _name; enum : _type</div><div class="line">    #else</div><div class="line">	#define NS_OPTIONS(_type, _name)</div><div class="line">		enum _name : _type _name; enum _name : type</div><div class="line">    #endif</div><div class="line">#else</div><div class="line">    #define NS_ENUM(_type, _name) _type _name; enum</div><div class="line">    #define NS_OPTIONS(_type, _name) _type _name; enum</div><div class="line">#endif</div></pre></td></tr></table></figure></p>
<p>由于需要分别处理不同情况，所以上述代码用多种方式来定义这两个宏。第一个#if用于判断编译器是否支持新式枚举。其中所用的布尔逻辑看上去相当复杂，不&gt;过其意思就是想判断编译器是否支持新的枚举特性。如果不支持，那么久用老式语法来定义枚举。<br>如果支持新特性，那么用NS_ENUM宏所定义的枚举类型展开后就是：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">typedef enum EOCConnectinState : NSUInteger EOCConnectionState;</div><div class="line">enum EOCConnectionState : NSUInteger &#123;</div><div class="line">	EOCConnectionStateDisconnected,</div><div class="line">	EOCConnectionStateConnecting,</div><div class="line">	EOCConnectionStateConnected,</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>根据是否要将代码按C++模式编译，NS_OPTIONS宏的定义方式也有所不同。如果不按C++编译，那么其展开方式就和NS_ENUM相同。若按C++编译，则展开后的代码略有不同。原因在于，用按位或运算来操作两个枚举值时，C++编译模式的处理办法与非C++模式不一样。而上面已经提到了，作为选项的枚举值经常需要用按位或运算来组合。在用或运算操作两个枚举值时，C++认为运算结果的数据类型应该是枚举的底层数据类型，也就是NSUInteger。而且C++不允许将这个底层类型“隐式转换”（implicit cast）为枚举类型本身。我们用EOCPermittedDirection来演示一下，假设按NS_ENUM方式将其展开：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">typedef enum EOCPermittedDirection : int EOCPermittedDirection;</div><div class="line">enum EOCPermittedDirection : int &#123;</div><div class="line">	EOCPermittedDirectionUp		= 1 &lt;&lt; 0,</div><div class="line">	EOCPermittedDirectionDown	= 1 &lt;&lt; 1,</div><div class="line">	EOCPermittedDirectionLeft	= 1 &lt;&lt; 2,</div><div class="line">	EOCPermittedDirectionRight	= 1 &lt;&lt; 3,</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>然后考虑下列代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">EOCPermittedDirection permittedDirections = EOCPermittedDirectionLeft | EOCPermittedDirectionUp;</div></pre></td></tr></table></figure></p>
<p>若编译器按C++模式编译（也可能是按Objective-C++模式编译），则会给出下列错误信息：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">error: cannot initilize a variable of type</div><div class="line">&apos;EOCPermittedDirection&apos; with an rvalue of type &apos;int&apos;</div></pre></td></tr></table></figure></p>
<p>如果想编译这行代码，就要将按位或操作的结果显式转换（explicit cast）为EOCPermittedDirection。所以，在C++模式下应该用另一种方式定义NS_OPTIONS宏，以便省去类型转换操作。鉴于此，凡是需要以按位或操作来组合的枚举都应使用NS_OPTIONS定义。若是枚举不需要互相组合，则应使用NS_ENUM来定义。</p>
<p>能够用到枚举的情况还有很多。前面已经提到，枚举可以表示选项与状态，然而还有许多东西也能用枚举来表示。比如状态码就是个好例子。可以把逻辑含义相似的一组状态码放入同一枚举集里，而不要用#define预处理指令或常量来定义。以枚举来表示样式（style）也很合宜。假如创建某个UI元素时可以使用不同的样式，那么在这种情况下就最应该把样式声明为枚举类型了。</p>
<p>最后再讲一种枚举的用法，就是在switch语句里。有时可以这样定义：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">typedef NS_ENUM(NSUInteger, EOCConnectionState)&#123;</div><div class="line">	EOCConnectionStateDisconnected,</div><div class="line">	EOCConnectionStateConnecting,</div><div class="line">	EOCConnectionStateConnected,</div><div class="line">&#125;;</div><div class="line"></div><div class="line">switch (_currentState) &#123;</div><div class="line">	EOCConnectionStateDisconnected:</div><div class="line">	// Handle disconnected state</div><div class="line">	break;</div><div class="line">	EOCConnectionStateConnecting:</div><div class="line">	// Handle connecting state</div><div class="line">	break;</div><div class="line">	EOCConnectionStateConnected:</div><div class="line">	// Handle connected state</div><div class="line">	break;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>我们总习惯在switch语句上加上default分支。然而，若是用枚举来定义状态机（State machine），则最好不要有default分支。这样的花，如果稍后又加了一种状态，那么编译器就会发出警告信息，提示新加入的状态并未在switch分支中处理。假如写上了default分支，那么它就会处理这个新状态，从而导致编译器不发警告信息。用NS_ENUM定义其他枚举类型时也要注意此问题。例如，在定义代表UI元素样式的枚举时，通常要确保switch语句能正确处理所有样式。</p>
<h2 id="要点"><a href="#要点" class="headerlink" title="要点"></a>要点</h2><p>应该用枚举来表示状态机的状态、传递给方法的选项以及状态码等值，给这些值起个易懂的名字。<br>如果把传递给某个方法的选项表示为枚举类型，而多个选项有可同时使用，那么久将各个选项值定义为2的幂，以便通过按位或操作将其组合起来。<br>用NS_ENUM于NS_OPTIONS洪来定义枚举类型，并指明其底层数据类型。这样做可以确保枚举是用开发者所选的底层数据类型实现出来的，而不会采用编译器所选的类型。<br>在处理枚举类型的switch语句中不要实现default分支。这样的话，加入新枚举之后，编译器就会提示开发者：switch语句并未处理所有枚举。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://BreakMind.github.io/2017/03/02/第5条：用枚举表示状态、选项、状态码/" data-id="cizsoq1g1000mke6qg0rla3xf" class="article-share-link">分享</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-第4条：多用类型常量，少用-define预处理指令" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/03/02/第4条：多用类型常量，少用-define预处理指令/" class="article-date">
  <time datetime="2017-03-02T08:44:02.000Z" itemprop="datePublished">2017-03-02</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/IOS-编写高质量代码/">IOS-编写高质量代码</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/03/02/第4条：多用类型常量，少用-define预处理指令/">第4条：多用类型常量，少用#define预处理指令</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>编写代码时经常要定义常量。例如，要写一个UI视图类，此视图显示出来之后就播放动画，然后消失。你可能想把播放动画的事件提取为常量。掌握了Objective-C与其C语言基础的人，也许会用这种方法来做：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">#define ANIMATION_DURATION 0.3</div></pre></td></tr></table></figure></p>
<p>上述预处理指令会把源代码中的ANIMATION_DURATION字符串替换为0.3。这可能就是你想要的效果，不过这样定义出来的常量没有类型信息。“持续”（duration）这个词看上去应该与实践有关，但是代码中又未明确指出。因此，预处理过程会把碰到的所有ANIMATION_DURATION一律替换成0.3，这样的话。假设此指令声明在某个头文件中，那么所有引入了这个头文件的代码，其ANIMATION_DURATION都会被替换。</p>
<p>要想解决此问题，应该设法利用编译器的某些特性才对。有个办法比用预处理器指令来定义常量更好。比方说，下面这行代码就定义了一个类型为NSTimeInterval的常量：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">static const NSTimeInterval kAnimationDuration = 0.3;</div></pre></td></tr></table></figure></p>
<p>请注意，用此方法定义的常量包含类型信息，其好处是清楚地描述了常量的含义。由此可知该常量类型为NSTimerInterval，这有助于为其编写开发文档。如果要定义许多常量，那么这种方式能令稍后阅读代码的人更易理解其意图。</p>
<p>还有注意常量名称。常用的命名法是：若常量局限于某“编译单元”（translation unit，也就是“实现文件”， implementation file）之内，则在前面加上字母k；若常量在类之外可见，则通常以类名为前缀。第19条详解了命名习惯（naming convention）。</p>
<p>定义常量的位置很重要，我们总喜欢在头文件里声明预处理指令，这样做真的很糟糕，当常量名称有可能互相出图更是如此。例如，ANIMATION_DURATION这个常量名就不该在头文件中，因为所有引入了这份头文件的其他文件都会出现这个名字。其实就连用static const定义的那个常量也不应出现在头文件里。因为Objective-C没有“命名空间”（namespace）这一概念，所以那样做等于声明了一个名叫kAnimationDuration的全局变量。此名称应该加上前缀，以表明其所属的类，例如可改为EOCViewClassAnimationDuration。本书第19条中深入讲解了一套清晰的命名方案。</p>
<p>若不打算公开某个常量，则应将其定义在使用该常量的实现文件里。比方说，要开发一个使用UIKit框架的IOS应用程序，其UIView子类中含有表示动画播放时间的常量，那么可以这样写：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">// EOCAnimatedView.h</div><div class="line">#import &lt;UIKit/UIKit.h&gt;</div><div class="line"></div><div class="line">@interface EOCAnimatedView : UIView</div><div class="line">- (void)animate;</div><div class="line">@end</div><div class="line"></div><div class="line">// EOCAnimatedView.m</div><div class="line">#import &quot;EOCAnimatedView.h&quot;</div><div class="line"></div><div class="line">static const NSTimeInterval kAnimationDuration = 0.3;</div><div class="line"></div><div class="line">@inplementation EOCAnimatedView</div><div class="line">- (void)animate&#123;</div><div class="line">	[UIViewanimateWithDuration:kAnimationDuration animation:^()&#123;</div><div class="line">		// Perform animations</div><div class="line">	&#125;];</div><div class="line">&#125;</div><div class="line">@end</div></pre></td></tr></table></figure></p>
<p>变量一定要同时用static与const来声明。如果试图修改由const修饰符所声明的变量，那么编译器就会报错。在本例中，我们正是希望这样：因为动画播放时为定值，所以不应修改。而static修饰符则意味着该变量仅在定义此变量的编译单元中可见。编译器每到一个编译单元，就会输出一份“目标文件”（object file）。在Objective-C的语境下，“编译单元一词通常指每个类的实现文件（以.m为后缀名）”。因此，在上述范例代码中声明的kAnimationDuratin变量，其作用域仅限于EOCAnimatedView.m所生成的目标文件中。假如声明此变量时不加static，则编译器会为它创建一个“外部符号”（external symbol）。此时若是另外一个编译单元也声明了同名变量，那么编译器就抛出一条错误消息：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">duplicate symbol _kAnimationDuration in:</div><div class="line">	EOCAnimatedView.o</div><div class="line">	EOCOtherView.o</div></pre></td></tr></table></figure></p>
<p>实际上，如果一个变量既声明为static，又声明为const，那么编译器根本不会创建符号，而是会像#define预处理指令一样，把所有遇到的变量都替换为常值。不过还是要记住：用这种方式定义的常量带有类型信息。</p>
<p>有时候需要对外公开某个常量。比方说，你可能要在类代码中调用NSNotificationCenter以通知他人。用一个对象来派发通知，令其他欲接收通知的对象向该对象注册，这样就能实现此功能了。派发通知时，需要使用字符串来表示此项通知的名称，而这个名字就可以声明为一个外界可见的常值变量（const variable）。这样的话，注册者无须知道实际字符串值，只需以常值变量来注册自己想要接收的通知即可。</p>
<p>此类常量需放在“全局符号表”（global symbol table）中，以便可以在定义该常量的编译单元之外使用。因此，其定义方式与上例演示的static const有所不同。应该这样来定义：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">// In the header file</div><div class="line">extern NSString *const EOCStringConstant;</div><div class="line"></div><div class="line">// In the implementation file</div><div class="line">NSString *const EOCStringConstant = @&quot;Value&quot;;</div></pre></td></tr></table></figure></p>
<p>这个常量在头文件中“声明”，且在实现文件中“定义”。注意const修饰符在常量类型中的位置。常量定义应从右至左解读，所以在本例中，EOCStringConstant就是“一个常量，而这个常量是指针，指向NSString对象”。这与需求相符：我们不希望有人改变此指针常量，使得其指向另一个NSString对象。</p>
<p>编译器看到头文件中的extern关键字，就能明白如何在引入此头文件的代码中处理该常量了。这个关键字是告诉编译器，在全局符号表中将会有一个名叫EOCStringConstant的符号。也就是说，编译器无需查看其定义，即允许代码使用此向量。因为它知道，当链接成二进制文件之后，肯定能找到这个常量。</p>
<p>此类常量必须要定义，而且只能定义一次。通常将其定义在与声明该常量的头文件相关的实现文件里。由实现文件生成目标文件时，编译器会在“数据段”（data section）为字符串分配存储空间。链接器会把此目标文件与其他目标文件相链接，以生成最终的二进制文件。凡是用到EOCStringConstant这个全局符号的地方，链接器都能将其解析。</p>
<p>因为符号要放在全局符号表里，所以命名常量时需谨慎。例如，在某应用程序中有个处理登录操作的类，在登录完成后会发出通知。派发通知所用的代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">// EOCLoginManager.h</div><div class="line">#import &lt;Foundation/Foundation.h&gt;</div><div class="line"></div><div class="line">extern NSString *const EOCLoginManagerDidLoginNotification;</div><div class="line"></div><div class="line">@interface EOCLoginManager : NSObject</div><div class="line">- (void)login;</div><div class="line">@end</div><div class="line"></div><div class="line">// EOCLoginManager.m</div><div class="line">#import &quot;EOCLoginManager.h&quot;</div><div class="line"></div><div class="line">NSString *const EOCLoginManagerDidLoginNotification = @&quot;EOCLoginManagerDidLoginNotification&quot;;</div><div class="line"></div><div class="line">@implementation EOCLoginManager;</div><div class="line"> - (void)login&#123;</div><div class="line">	// Perform login asynchronously, then call &apos;p_didLogin&apos;.</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)p_didLogin&#123;</div><div class="line">	[[NSNotificationCenter defaultCenter] postNotificationName:EOCLoginManagerDidLoginNotification object:nil];</div><div class="line">&#125;</div><div class="line">@end</div></pre></td></tr></table></figure></p>
<p>注意常量的名字。为避免名称冲突，最好是用与之相关的类名做前缀。系统框架中一般都这样做。例如UIKit就按照这种方式来声明用作通知名称的全局常量。其中有类似UIApplicationDidEnterBackgroundNotification与UIApplicationWillEnterForegroundNotification这样的常量名。<br>其他类型的常量也是如此。假如要把前列中EOCAnimationView类里的动画播放时长对外公布，那么可以这样声明：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">// EOCAnimatedView.h</div><div class="line">extern const NSTimeInterval EOCAnimatedViewAnimationDuration;</div><div class="line"></div><div class="line">// EOCAnimatedView.m</div><div class="line">const NSTimeInterval EOCAnimatedViewAnimationDuration = 0.3;</div></pre></td></tr></table></figure></p>
<p>这样定义常量要优于使用#define预处理指令，因为编译器会确保常量值不变。一旦在EOCAnimatedView.m中定义好，即可随处使用。而采用预处理指令所定义的常量可能会无意中遭人修改，从而导致应用程序各个部分所使用的值互不相同。</p>
<p>总之，勿使用预处理指令定义常量，而应该借助编译器来确保常量正确，比方说可以在实现文件中用static const来声明常量，也可以声明一些全局常量。</p>
<h2 id="要点"><a href="#要点" class="headerlink" title="要点"></a>要点</h2><p>不要用预处理指令定义常量。这样定义出来的常量不含类型信息，编译器只是会在编译前据此执行查找和替换操作。即使有人重新定义了常量值，编译器也不会产生警告信息，这将导致应用程序中的常量值不一致。<br>在实现文件中使用static const来定义“只在编译单元内可见的常量”（translation-unit-specific constant）。由于此类常量不在全局符号表中，所以无须为其名称加前缀。<br>在头文件中使用extern来声明全局常量，并在相关实现文件中定义其值。这种常量要出现在全局符号表中，所以其名称应加以区隔，通常用与之相关的类名做前缀。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://BreakMind.github.io/2017/03/02/第4条：多用类型常量，少用-define预处理指令/" data-id="cizsoq1gn000tke6q9dpcinx8" class="article-share-link">分享</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-第3条：多用字面量语法，少用与之等价的方法" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/03/02/第3条：多用字面量语法，少用与之等价的方法/" class="article-date">
  <time datetime="2017-03-02T06:00:16.000Z" itemprop="datePublished">2017-03-02</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/IOS-编写高质量代码/">IOS-编写高质量代码</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/03/02/第3条：多用字面量语法，少用与之等价的方法/">第3条：多用字面量语法，少用与之等价的方法</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>编写Objective-C程序时，总会用到某几个类，它们属于Foundation框架。虽然从技术上来说，不用Foundation框架也能写出Objective-C代码，但实际上却经常要用到此框架。这几个类是NSString、NSNumber、NSArray、NSDictionary。从类名上即可看出各自所表示的数据结构。</p>
<p>Objective-C以语法繁杂而著称。事实上的确是这样。不过，从Objective-C 1.0起，有一种非常简单的方式能创建NSString对象。这就是“字符串字面量”（string literal），其语法如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">NSString *someString = @&quot;Effective Objective-C 2.0&quot;;</div></pre></td></tr></table></figure></p>
<p>如果不用这种语法的花，就要以常见的alloc及init方法来分配并初始化NSString对象了。在版本较新的编译器中，也能用这种字面量语法来声明NSNumber、NSArray、NSDictionary类的实例。使用字面量语法（literal syntax）可以缩减源代码长度，使其更为易读。</p>
<h2 id="字面数值"><a href="#字面数值" class="headerlink" title="字面数值"></a>字面数值</h2><p>有时需要把整数、浮点数、布尔值封入Objective-C对象中。这种情况下可以用NSNumber类，该类可以处理多种类型的数值。若是不用字面量，那么就需要按下述方式创建实例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">NSNumber *someNumber = [NSNumber numberWithInt:1];</div></pre></td></tr></table></figure></p>
<p>上面这行代码创建了一个数字，将其值设为整数1。然而使用字面量能令代码更为整洁：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">NSNumber *someNumber = @1;</div></pre></td></tr></table></figure></p>
<p>大家可以看到，字面量语法更为精简。不过它还有很多好处。能够以NSNumber实例表示的所有数据类型都可使用该语法。例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">NSNumber *intNumber = @1;</div><div class="line">NSNumber *floatNumber = @2.5f;</div><div class="line">NSNumber *doubleNumber = @3.14159;</div><div class="line">NSNumber *boolNumber = @YES;</div><div class="line">NSNumber *charNumber = @&apos;a&apos;;</div></pre></td></tr></table></figure></p>
<p>字面量语法也适用于下述表达式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">int x = 5;</div><div class="line">float y = 6.23f;</div><div class="line">NSNumber *expressionNumber = @(x * y);</div></pre></td></tr></table></figure></p>
<p>以字面量来表示数值十分有用。这样走可以令NSNumber对象变得整洁，因为声明中只包含数值，而没有多余的语法成分。</p>
<h2 id="字面量数组"><a href="#字面量数组" class="headerlink" title="字面量数组"></a>字面量数组</h2><p>数组是常用的数据结构。如果不使用字面量语法，那么就要这样来创建数组：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">NSArray *animals = [NSArray arrayWithObjects:@&quot;cat&quot;, @&quot;dog&quot;, @&quot;mouse&quot;, @&quot;badger&quot;, nil];</div></pre></td></tr></table></figure></p>
<p>使用字面量语法来创建则是：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">NSArray *animal = @[@&quot;cat&quot;, @&quot;dog&quot;, @&quot;mouse&quot;, @&quot;badger&quot;, nil];</div></pre></td></tr></table></figure></p>
<p>上面这种做法不仅简单，而且还利于操作数组。数组的常见操作就是取某个下标所对应的对象，这用字面量来做更为容易。如果不用字面量，那么通常会用“objectAtIndex:”方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">NSString *dog = [animals objectiveAtIndex:1];</div></pre></td></tr></table></figure></p>
<p>若使用字面量，则是：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">NSString *dog = animal[1];</div></pre></td></tr></table></figure></p>
<p>这也叫做“取下标”操作（subscripting），与使用字面量语法的其他情况一样，这种方式也更为简洁、更易理解，而且与其他语言中依下标来访问数组元素时所用的语法类似。<br>不过用字面量语法创建数组时要注意，若数组元素对象中有nil，则会抛出异常，因为字面量语法实际上只是一种“语法糖”（syntactic sugar），其效果等于是先创建了一个数组，然后把方括号内的所有对象都加到这个数组中。抛出的异常会使这样：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">*** Terminating app due to uncaught exception</div><div class="line">&apos;NSInvalidArgumentException&apos;,reason:&apos;***</div><div class="line">-[__NSPlaceholderArray initWithObjects:count:]: attempt to insert nil object from objects[0]&apos;</div></pre></td></tr></table></figure></p>
<p>在改用字面量语法来创建数组时就会遇到这个问题。下面这段代码分别以两种语法创建数组：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">id object1 = /* ... */;</div><div class="line">id object2 = /* ... */;</div><div class="line">id object3 = /* ... */;</div><div class="line"></div><div class="line">NSArray *arrayA = [NSArray array WithObjects:object1, object2, object3, nil];</div><div class="line">NSArray *arrayB = @[object1, object2, object3];</div></pre></td></tr></table></figure></p>
<p>大家想想：如果object1与object3都指向了有效的Objective—C对象，而object2是nil，那么会出现什么情况呢？按字面量语法创建数组arrayB时会抛出异常。arrayA虽然能创建出来，但是其中却只含有object1一个对象。原因在于，”arrayWithObjects:“方法会一次处理各个参数，直到发现nil为止，由于object2是nil，所以该方法会提前结束。<br>这个微妙的差别表明，使用字面量语法更为安全。抛出异常令应用程序终止执行，这比创建好数组之后发现元素个数少了要好。向数组中插入nil通常说明程序有错，而通过异常可以更快地发现这个错误。</p>
<h2 id="字面量字典"><a href="#字面量字典" class="headerlink" title="字面量字典"></a>字面量字典</h2><p>”字典“（Dictionary）是一种影射型数据结构，可想起中添加键值对。与数组一样，Objective-C代码也经常用到字典。其创建方式如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">NSDictionary *personData = [NSDictionarydictionary WithObjectsAndKeys:</div><div class="line">	@&quot;Matt&quot;, @&quot;firstName&quot;,</div><div class="line">	@&quot;Galloway&quot;, @&quot;lastName&quot;,</div><div class="line">	@&quot;NSNumber numberWithInt:28&quot;, @&quot;age&quot;,</div><div class="line">];</div></pre></td></tr></table></figure></p>
<p>这样写令人困惑，因为其顺序是&lt;对象&gt;，&lt;键&gt;，&lt;对象&gt;，&lt;键&gt;。这与通常理解的顺序相反，我们一般认为是把”键“映射到”对象“。因此，这种写法不容易读懂。如果改用字面量语法，就清晰多了：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">NSDictionary *personData = @&#123;</div><div class="line">	@&quot;firstName&quot;:@&quot;Matt&quot;,</div><div class="line">	@&quot;lastName&quot;:@&quot;Galloway&quot;,</div><div class="line">	@&quot;age&quot;:@28&#125;;</div></pre></td></tr></table></figure></p>
<p>上面这种写法更简明，而且键出现在对象之前，理解起来较顺畅。此范例代码还说明了使用字面量数值的好处。字典中的对象和键必须都是Objective-C对象，所以不能把整数直接放进去，而要将其封装在NSNumber实例中才行。使用字面量语法很容易就能做到这一点，只需给数字前加一个@字符即可。</p>
<p>与数组一样，用字面量语法创建字典时也有个问题，那就是一旦有值为nil，便会抛出异常。不过基于同样的原因，这也是个好事。加入在创建字典时不小心用了空值对象，那么”dictionaryWithObjectsAndKeys:“方法就会在首个nil之前停下来，并抛出异常，这有助于查错。</p>
<p>字典也可以像数组那样用字面量语法访问。按照特定键访问其值得传统做法是：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">NSString *lastName = [personData objectForKey:@&quot;lastName&quot;];</div></pre></td></tr></table></figure></p>
<p>与之等效的字面量语法则是：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">NSString *lastName = personData[@&quot;lastName&quot;];</div></pre></td></tr></table></figure></p>
<p>这样写也省去了冗赘的语法，令此行代码简单易读。</p>
<h2 id="可变数组与字典"><a href="#可变数组与字典" class="headerlink" title="可变数组与字典"></a>可变数组与字典</h2><p>通过取下标操作，可以访问数组中某个下标或字典中某个键所对应的元素。如果数组与字典对象是可变的（mutable），那么也能通过下标修改其中的元素值。修改可变元素与字典内容的标准做法是：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">[mutableArray replaceObjectAtIndex:1 withObject:@&quot;dog&quot;];</div><div class="line">[mutableDictionary setObject:@&quot;Galloway&quot; forKey:@&quot;lastName&quot;];</div></pre></td></tr></table></figure></p>
<p>若换用取下标操作来写，则是：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">mutableArray[1] = @&quot;dog&quot;;</div><div class="line">mutableDictionary[@&quot;lastName&quot;] = @&quot;Galloway&quot;;</div></pre></td></tr></table></figure></p>
<h2 id="局限性"><a href="#局限性" class="headerlink" title="局限性"></a>局限性</h2><p>字面量语法有个小小的限制，就是除了字符串以外，所创建出来的对象必须属于Foundation框架才行。如果自定义了这些类的子类，则无法用字面量语法创建其对象。要想创建自定义子类的实例，必须采用”非字面量语法“（nonliteral syntax）。然而，由于NSArray、NSDictionary、NSNumber都是业已定型的”子族“（class cluster，参见第9条），因此很少有人会从其中自定义子类，真要那样做也比较麻烦。而且一般来说，标准的实现已经很好了，无需再改动。创建字符串时可以使用自定义的子类，然而必须要修改编译器的选项才行。除非你明白这样做的后果，否则不鼓励使用此选项，用NSString就足够了。</p>
<p>使用字面量语法创建出来的字符串、数组、字典对象都是不可变的（immutable）。若想要可变版本的对象，则需复制一份：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">NSMutableArray *mutable = [@[@1,  @2,  @3,  @4, @5]mutableCopy];</div></pre></td></tr></table></figure></p>
<p>这么做会多调用一个方法，而且还要再创建一个对象，不过使用字面量语法所带来的好处还是多余上述缺点的。</p>
<h2 id="要点"><a href="#要点" class="headerlink" title="要点"></a>要点</h2><p>应该使用字面量语法来创建字符串、数值、数组、字典。与创建此类对象的常规方法相比，这么做更加简明扼要。<br>应该通过取下标操作来访问数组下标或字典中的键所对应的元素。<br>用字面量语法创建数组或字典时，若值中有nil，则会抛出异常。因此，务必确保值里不含nil。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://BreakMind.github.io/2017/03/02/第3条：多用字面量语法，少用与之等价的方法/" data-id="cizsoq1g7000oke6q7m3a9n77" class="article-share-link">分享</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-第2条：在类的头文件中尽量少引入其他都文件" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/03/02/第2条：在类的头文件中尽量少引入其他都文件/" class="article-date">
  <time datetime="2017-03-01T17:00:12.000Z" itemprop="datePublished">2017-03-02</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/IOS-编写高质量代码/">IOS-编写高质量代码</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/03/02/第2条：在类的头文件中尽量少引入其他都文件/">第2条：在类的头文件中尽量少引入其他都文件</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>与C和C++一样，Objective-C也使用“头文件”（header file）与“实现文件”（implementation file）来区隔代码。用Objective-C语言编写“类”（class）的标准方式为：以类名做文件名，分别创建两个文件，头文件后缀用.h，实现文件后缀用.m。创建好一个类之后，其代码看上去如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">// EOCPerson.h</div><div class="line">#import &lt;Foundation/Foundation.h&gt;</div><div class="line"></div><div class="line">@interface EOCPerson : NSObject</div><div class="line">@property (nonatomic, copy) NSString * firstName;</div><div class="line">@property (nonatomic, copy) NSString * lastName;</div><div class="line">@end</div><div class="line"></div><div class="line">// EOCPerson.m</div><div class="line">#import &quot;EOCPerson.h&quot;</div><div class="line"></div><div class="line">@implementation EOCPerson</div><div class="line">// Implementation of methods</div><div class="line"></div><div class="line">@end</div></pre></td></tr></table></figure></p>
<p>用Objective-C语言编写任何类几乎都需要引入Foundation.h。如果不在该类本身引入这个文件的话，那么就要引入与其超类所属框架相对应的“基本头文件”（base header file）。例如，在创建IOS应用程序时，通常会继承UIViewController类。而这些子类的头文件需要引入UIKit.h。</p>
<p>现在看来，EOCPerson类还好。其头文件引入了整个Foundation框架，不过这并没有问题。如果此类继承自Foundation框架中的某个类，那么EOCPerson类的使用者（consumer）可能会用到其基类中的许多内容。继承自UIViewController的那些类也是如此，其使用者可能会用到UIKit中的大部分内容。</p>
<p>过段时间，你可能又创建了一个名为EOCEmployer的新类，然后可能觉得每个EOCPerson实例都应该有一个EOCEmployer。于是，直接为其添加一项属性：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">// EOCPerson.h</div><div class="line">#import &lt;Foundation/Foundation.h&gt;</div><div class="line">@interface EOCPerson : NSObject</div><div class="line">@property (nonatomic, copy) NSString *firstName;</div><div class="line">@property (nonatomic, copy) NSString *lastName;</div><div class="line">@property (nonatomic, strong) EOCEmployer *employer;</div><div class="line">@end</div></pre></td></tr></table></figure></p>
<p>然而这么做有个问题，就是在编译引入了EOCPerson.h的文件时，EOCEmployer类并不可见。不便强迫开发者在引入EOCPerson.h时必须一并引入EOCEmployer.h，所以，常见办法是在EOCPerson.h中加入下面这行：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">#import &quot;EOCEmployer.h&quot;</div></pre></td></tr></table></figure></p>
<p>这种办法可行，但是不够优雅。在编译一个使用了EOCPerson类的文件时，不需要知道EOCEmployer类的全部细节，只需要知道有一个类名叫EOCEmployer就好，所幸有个办法能把这一情况告诉编译器：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">@class EOCEmployer;</div></pre></td></tr></table></figure></p>
<p>这叫做“向前声明”（forward declaring）该类。现在EOCPerson的头文件变成了这样：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">// EOCPerson.h</div><div class="line">#import &lt;Foundation/Foundation.h&gt;</div><div class="line"></div><div class="line">@class EOCEmployer;</div><div class="line"></div><div class="line">@interface EOCPerson : NSObject</div><div class="line">@property (nonatomic, copy) NSString *firstName;</div><div class="line">@property (nonatomic, copy) NSString *lastName;</div><div class="line">@property (nonatomic, strong) EOCEmployer *employer;</div><div class="line">@end</div></pre></td></tr></table></figure></p>
<p>EOCPerson类的实现文件则需要引入EOCEmployer类的头文件，因为若要使用后者，则必须知道其所有接口细节。于是，实现文件就是：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">// EOCPerson.m</div><div class="line">#import &quot;EOCPerson.h&quot;</div><div class="line">#import &quot;EOCEmployer.h&quot;</div><div class="line"></div><div class="line">@implementation EOCPerson</div><div class="line">// Implementation of methods</div><div class="line">@end</div></pre></td></tr></table></figure></p>
<p>将引入头文件的时机尽量延后，只在确有需要时才引入，这样就可以减少类的使用者所需引入的头文件数量。假设本例把EOCEmployer.h引入到EOCPerson.h，那么只要引入EOCPerson.h，就会一并引入EOCEmployer.h的所有内容。此过程若持续下去，则要引入许多根本用不到的内容，这当然会增加编译事件。</p>
<p>向前声明也解决了两个类互相引用的问题。假设要为EOCEmployer类加入新增及删除雇员的方法，那么其头文件中会加入下述定义：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">-(void)addEmployee:(EOCPerson *)person;</div><div class="line">-(void)removeEmployee:(EOCPerson *)person;</div></pre></td></tr></table></figure></p>
<p>此时，若要编译EOCEmployer，则编译器必须知道EOCPerson这个类，而要编译EOCPerson，则又必须知道Employer。如果在各自头文件中引入对方的头文件，则会导致“循环引用”（chicken-and-egg situation）。当解析其中的一个头文件时，编译器会发现它引入了另一个头文件，而那个头文件又回过头来引用第一个头文件。使用#import而非#include指令虽然不会导致死循环，但却意味着这两个类里有一个无法被正确编译。如果不信的话，读者可以自己试试。</p>
<p>但是有时候必须要在头文件中引入其他头文件。如果你写的类继承自某个超类，则必须引入定义那个超类的头文件。同理，如果要声明你写的类遵从某个协议（protocol），那么该协议必须有完整定义，切不能使用向前声明。向前声明只能告诉编译器有某个协议，而此时编译器却要知道该协议中定义的方法。<br>例如，要从图形类中继承一个矩形类，切令其遵循绘制协议：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">#import &quot;EOCShape.h&quot;</div><div class="line">#import &quot;EOCDrawable.h&quot;</div><div class="line"></div><div class="line">@interface EOCRectangle : EOCShape&lt;EOCDrawable&gt;</div><div class="line">@property (nonatomic, assign) float width;</div><div class="line">@property (nonatomic, assign) float height;</div></pre></td></tr></table></figure></p>
<p>第二条#import是难免的。鉴于此，最好是把协议单独放在一个头文件中。要是把EOCDrawable协议放在了某个大的头文件里，那么只要引入此协议，就必定会引入那个头文件中的全部内容，如此一来，就像上面说的那样，会产生相互依赖问题，而且还会增加编译时间。</p>
<p>然而有些协议，例如“委托协议”（delegate protocol，参见第23条），就不用单独写一个头文件了。在那种情况下，协议只有与接收协议委托的类放在一起定义才有意义。此时最好能在实现文件中声明此类实现了该委托协议，并把这段实现代码放在“class-continuation分类”（class-continuation category，参见第27条）里。这样的话，只要在实现文件中引入包括委托协议的头文件即可，而不需将其放在公共头文件（public header file）里。</p>
<p>每次在头文件中引入其他头文件之前，都要先问问自己这样做是否确有必要。如果可以用向前声明取代引入，那么就不要引入。若因为要实现属性、实例变量或者要遵循协议而必须引入头文件，则应尽量将其移至“class-continuation分类”中（参见第27条）。这样做不仅可以缩减编译事件，而且还能降低彼此依赖程度。若是依赖关系过于复杂，则会给维护带来麻烦，而且，如果只想把代码的某个部分开放为公共API的话，太复杂的以来关系也会出问题。</p>
<h2 id="要点"><a href="#要点" class="headerlink" title="要点"></a>要点</h2><p>除非确有必要，否则不要引入头文件。一般来说，应在某个类的头文件中使用向前声明来提及别的类，并在实现文件中引入那些类的头文件。这样做可以尽量降低类之间的耦合（coupling）。<br>有时无法使用向前声明，比如要声明某个类遵循一项协议。这种情况下，尽量把“该类遵循某协议”的这条声明移到“class-continuation”分类中。如果不行的话，就把协议单独放在一个头文件中，然后将其引入。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://BreakMind.github.io/2017/03/02/第2条：在类的头文件中尽量少引入其他都文件/" data-id="cizsoq1gk000rke6qla9j5kog" class="article-share-link">分享</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-第1条：熟悉Objective-C" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/03/02/第1条：熟悉Objective-C/" class="article-date">
  <time datetime="2017-03-01T16:03:55.000Z" itemprop="datePublished">2017-03-02</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/IOS-编写高质量代码/">IOS-编写高质量代码</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/03/02/第1条：熟悉Objective-C/">第1条-熟悉Objective-C</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>第一章节<br>熟悉Objective-C</p>
<p>Objective-C通过一套全新语法，在C语言基础上添加了面向对象特性。Objective-C的语法中频繁使用方括号，而且不吝于写出极长的方法名，这通常令许多人觉得此语言为冗长。其实这样写出来的代码十分易读，只是C++或Java程序员不太能适应。</p>
<p>Objective-C语言学起来很快，但有很多微妙细节需要注意，而且还有许多容易为人所忽视的特性。另一方面，有些开发者并未完全理解或是滥用某些特性，导致写出来的代码难于维护且不易调试。本章讲解基础知识，后续各章谈论语言及其相关框架中的各个特定话题。</p>
<h2 id="第一条：了解Objective-C语言的起源"><a href="#第一条：了解Objective-C语言的起源" class="headerlink" title="第一条：了解Objective-C语言的起源"></a>第一条：了解Objective-C语言的起源</h2><p>Objective-C与C++、Java等面向对象语言类似，不过很多方面有所差别。若是用过另一种面向对象语言，那么就能理解Objective-C所用的许多范式与模板了。然而语法上也许会显得陌生，因为该语言使用“消息结构”（messaging struct）而非“函数调用”（function calling）。Objective-C语言由Smalltalk演化而来，后者是消息型语言的鼻祖。消息与函数调用之间的区别看上去就像这样：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">// Messaging (Objective-C)</div><div class="line">Object * obj = [Object new];</div><div class="line">[obj performWith:parameter1 and:parameter2];</div><div class="line"></div><div class="line">// Function calling (C++)</div><div class="line">Object * obj = new Object;</div><div class="line">obj-&gt;perform(parameter1, parameter2);</div></pre></td></tr></table></figure></p>
<p>关键区别在于：使用消息结构的语言，其运行时所应执行的代码由运行环境来决定；而使用函数调用的语言，则由编译器决定。如果范例代码中调用的函数是多态的，那么在运行时就就要按照“虚函数表（virtual table）”来查出到底应该执行哪个函数实现。而采用消息结构的语言，不论是否多态，总是在运行时才会去查找所要执行的方法。实际上，编译器甚至不关心接收消息的对象是何种类型。接收消息的对象问题也要在运行时处理，其过程叫做“动态绑定（dynamic binding）”，第11条会详述其细节。</p>
<p>Objective-C的重要工作都由“运行期组件”（runtime component）而非编译器来完成。使用Objective-C的面向对象特性所需的全部数据结构及函数都在运行期组件里面。举例来说，运行期组件中含有全部内存管理方法。运行期组件本质上就是一种与开发者所编代码相链接的“动态库”（dynamic library），其代码能把开发者编写的所有程序粘合起来。这样的话，只需更新运行期组件，即可提升应用程序性能。而那种许多工作都在“编译期”（compile time）完成的语言，若想获得类似的性能提升，则要重新编译应用程序代码。</p>
<p>Objective-C是C的“超集”（superset），所以C语言中的所有功能在编写Objective-C代码时依然适用。因此，必须同时掌握C与Objective-C这两门语言的核心概念，方能写出高效的Objective-C代码来。其中尤为重要的是理解C语言的内存模型（memory model），这有助于理解Objective-C的内存模型及其“引用计数”（reference counting）机制的工作原理。若要理解内存模型，则需明白：Objective-C语言中的指针是用来指示对象的。想要声明一个变量，令其指代某个对象，可用如下语法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">NSString * someString = @&quot;The string&quot;;</div></pre></td></tr></table></figure></p>
<p>这种语法基本上是照搬C语言的，它声明了一个名为someThing的变量，其类型是NSString*。也就是说，此变量为指向NSString的指针。所有Objective-C语言的对象都必须这样声明，因为对象所占内存总是分配在“堆控件”（heap space）中，而绝不会分配在“栈”（stack）上。不能再栈上分配Objective-C对象：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">NSString stackString;</div><div class="line">// error: interface type cannot be statically allocated</div></pre></td></tr></table></figure></p>
<p>someString变量指向分配在堆里的某块内存，其中含有一个NSString对象。也就是说，如果再创建一个变量，令其指向同一地址，那么并不拷贝该对象，只是这两个变量会同时指向此对象：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">NSString *someString = @&quot;The string&quot;;</div><div class="line">NSString *anotherString = someString;</div></pre></td></tr></table></figure></p>
<p>只有一个NSString实例，然而又两个变量指向此实例。两个变量都是NSString*型，这说明当期那“栈帧”（stack frame）里面分配了两块内存，每块内存的带下都能容下一枚指针（在32位架构的计算机上是4字节，64位计算机上是8字节）。这两块内存里的值都一样，就是NSString实例的内存地址。</p>
<p>图1-1 描述了此时的内存布局。存放在NSString实例中的数据含有代表字符串实际内容的字节。</p>
<pre><code>图1-1 此内存布局图演示了一个分配在堆中的NSString实例，有两个分配在栈上的指针指向该实例
</code></pre><p>分配在堆中的内存必须直接管理，而分配在栈上用于保存变量的内存则会在其栈帧弹出时自动清理。</p>
<p>Objective-C将堆内存管理抽象出来了。不需要用malloc及free来分配或释放对象所占内存。Objective-C运行期环境把这部分工作抽象为一套内存管理架构，名叫“引用计数”（参见第29条）。</p>
<p>在Objective-C代码中，有时会遇到定义里不含* 变量，他们可能会使用“栈控件”（stack space）。这些变量所保存的不是Objective-C对象。比如CoreGraphic框架中的CGRect就是个例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">CGRect frame;</div><div class="line">frame.origin.x = 0.0f;</div><div class="line">frame.origin.y = 10.0f;</div><div class="line">frame.size.width = 100.0f;</div><div class="line">frame.size.height = 150.0f;</div></pre></td></tr></table></figure></p>
<p>CGRect是C结构体，其定义是：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">struct CGRect&#123;</div><div class="line">	CGPoint origin;</div><div class="line">	CGSize size;</div><div class="line">&#125;;</div><div class="line">typedef struct CGRect CGRect;</div></pre></td></tr></table></figure></p>
<p>整个系统框架都在使用这种结构体，因为如果改用Objective-C对象来做的花，性能会受影响。与创建结构体相比，创建对象还需要额外开销，例如分配及释放堆内存等。如果只需要保存int、float、double、char等“非对象类型”（nonobject type），那么通常使用CGRect这种结构体就可以了。</p>
<p>在着手编写Objective-C代码之前，建议读者先看看C语言教程，以熟悉其语法。若是还没熟悉C语言就直接进入Objective-C的话，那么某些语法也许会令你困惑。</p>
<h2 id="要点"><a href="#要点" class="headerlink" title="要点"></a>要点</h2><p>Objective-C为C语言添加了面向对象特性，是其超集。Objective-C使用动态绑定的消息结构，也就是说，在运行时才会检查对象类型。接受一条消息之后，究竟应执行何种代码，由运行期环境而非编译器来决定。<br>理解C语言的核心概念有助于写好Objective-C程序。尤其要掌握内存模型与指针。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://BreakMind.github.io/2017/03/02/第1条：熟悉Objective-C/" data-id="cizsoq1ff000cke6qq7wqakdr" class="article-share-link">分享</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Cocoapod安装与简单使用" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/03/01/Cocoapod安装与简单使用/" class="article-date">
  <time datetime="2017-03-01T13:27:15.000Z" itemprop="datePublished">2017-03-01</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/MAC/">MAC</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/03/01/Cocoapod安装与简单使用/">Cocoapod安装与简单使用</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <hr>
<h1 id="首次使用"><a href="#首次使用" class="headerlink" title="首次使用"></a>首次使用</h1><h2 id="增加一个Repo"><a href="#增加一个Repo" class="headerlink" title="增加一个Repo"></a>增加一个Repo</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">pod repo add AFNetworking &quot;https://github.com/AFNetworking/AFNetworking.git&quot;</div></pre></td></tr></table></figure>
<h2 id="显示本地的Repo"><a href="#显示本地的Repo" class="headerlink" title="显示本地的Repo"></a>显示本地的Repo</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">pod repo list</div></pre></td></tr></table></figure>
<h2 id="查找需要添加的组件"><a href="#查找需要添加的组件" class="headerlink" title="查找需要添加的组件"></a>查找需要添加的组件</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">pod search AFNetworking</div></pre></td></tr></table></figure>
<h2 id="查找后会显示一堆Repo，但是这里我们只需要看到第一个"><a href="#查找后会显示一堆Repo，但是这里我们只需要看到第一个" class="headerlink" title="查找后会显示一堆Repo，但是这里我们只需要看到第一个"></a>查找后会显示一堆Repo，但是这里我们只需要看到第一个</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">-&gt; AFNetworking (3.1.0)</div><div class="line">   A delightful iOS and OS X networking framework.</div><div class="line">   pod &apos;AFNetworking&apos;, &apos;~&gt; 3.1.0&apos;</div><div class="line">   - Homepage: https://github.com/AFNetworking/AFNetworking</div><div class="line">   - Source:   https://github.com/AFNetworking/AFNetworking.git</div><div class="line">   - Versions: 3.1.0, 3.0.4, 3.0.3, 3.0.2, 3.0.1, 3.0.0, 3.0.0-beta.3, 3.0.0-beta.2, 3.0.0-beta.1, 2.6.3, 2.6.2, 2.6.1, 2.6.0, 2.5.4, 2.5.3,</div><div class="line">   2.5.2, 2.5.1, 2.5.0, 2.4.1, 2.4.0, 2.3.1, 2.3.0, 2.2.4, 2.2.3, 2.2.2, 2.2.1, 2.2.0, 2.1.0, 2.0.3, 2.0.2, 2.0.1, 2.0.0, 2.0.0-RC3, 2.0.0-RC2,</div><div class="line">   2.0.0-RC1, 1.3.4, 1.3.3, 1.3.2, 1.3.1, 1.3.0, 1.2.1, 1.2.0, 1.1.0, 1.0.1, 1.0, 1.0RC3, 1.0RC2, 1.0RC1, 0.10.1, 0.10.0, 0.9.2, 0.9.1, 0.9.0,</div><div class="line">   0.7.0, 0.5.1 [master repo]</div><div class="line">   - Subspecs:</div><div class="line">     - AFNetworking/Serialization (3.1.0)</div><div class="line">     - AFNetworking/Security (3.1.0)</div><div class="line">     - AFNetworking/Reachability (3.1.0)</div><div class="line">     - AFNetworking/NSURLSession (3.1.0)</div><div class="line">     - AFNetworking/UIKit (3.1.0)</div></pre></td></tr></table></figure>
<h3 id="将组件的名称以及版本号添加到当前项目的根目录内的Podfile文件内"><a href="#将组件的名称以及版本号添加到当前项目的根目录内的Podfile文件内" class="headerlink" title="将组件的名称以及版本号添加到当前项目的根目录内的Podfile文件内"></a>将组件的名称以及版本号添加到当前项目的根目录内的Podfile文件内</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"># Uncomment the next line to define a global platform for your project</div><div class="line"> platform :ios, &apos;9.0&apos;(原来注释掉的，现在去掉)</div><div class="line"></div><div class="line">target &apos;NSThreadTest&apos; do</div><div class="line">  # Uncomment the next line if you&apos;re using Swift or would like to use dynamic frameworks</div><div class="line">  # use_frameworks!</div><div class="line"></div><div class="line">  # Pods for NSThreadTest</div><div class="line">  pod &apos;AFNetworking&apos;, &apos;~&gt; 3.1.0&apos; (原来没有这一行，现在我们需要增加上名称以及对应的版本号)</div><div class="line">end</div></pre></td></tr></table></figure>
<h2 id="在项目里安装组件（在项目的根目录下，也就是有Podfile文件的那个目录内），运行以下命令"><a href="#在项目里安装组件（在项目的根目录下，也就是有Podfile文件的那个目录内），运行以下命令" class="headerlink" title="在项目里安装组件（在项目的根目录下，也就是有Podfile文件的那个目录内），运行以下命令"></a>在项目里安装组件（在项目的根目录下，也就是有Podfile文件的那个目录内），运行以下命令</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">pod install</div></pre></td></tr></table></figure>
<h2 id="在我的终端上面显示"><a href="#在我的终端上面显示" class="headerlink" title="在我的终端上面显示"></a>在我的终端上面显示</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">Analyzing dependencies</div><div class="line">Downloading dependencies</div><div class="line">Installing AFNetworking (3.1.0)</div><div class="line">Generating Pods project</div><div class="line">Integrating client project</div><div class="line">Sending stats</div></pre></td></tr></table></figure>
<h2 id="打开工程"><a href="#打开工程" class="headerlink" title="打开工程"></a>打开工程</h2><p>注意，这个时候不要再打开.xcodeproj 工程，而是.xcworkspace，这个时候就可以看到所有的内容都在里面了。</p>
<hr>
<h2 id="iOS-删除已经配置的类库和移除CocoaPods"><a href="#iOS-删除已经配置的类库和移除CocoaPods" class="headerlink" title="iOS 删除已经配置的类库和移除CocoaPods"></a>iOS 删除已经配置的类库和移除CocoaPods</h2><p>请参照：<a href="http://www.jianshu.com/p/552f21a989ba" target="_blank" rel="external">http://www.jianshu.com/p/552f21a989ba</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://BreakMind.github.io/2017/03/01/Cocoapod安装与简单使用/" data-id="cizsoq1ed0001ke6qtynz1gkt" class="article-share-link">分享</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-MAC下使用CLOC进行代码量统计" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/02/28/MAC下使用CLOC进行代码量统计/" class="article-date">
  <time datetime="2017-02-28T07:12:23.000Z" itemprop="datePublished">2017-02-28</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/MAC/">MAC</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/02/28/MAC下使用CLOC进行代码量统计/">MAC下使用CLOC进行代码量统计</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>使用参照博客：<br><a href="http://echohn.github.io/2016/09/24/use-cloc-to-count-your-code/" target="_blank" rel="external">http://echohn.github.io/2016/09/24/use-cloc-to-count-your-code/</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://BreakMind.github.io/2017/02/28/MAC下使用CLOC进行代码量统计/" data-id="cizsoq1f80009ke6qttwe7k21" class="article-share-link">分享</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Homebrew" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/02/28/Homebrew/" class="article-date">
  <time datetime="2017-02-28T07:00:09.000Z" itemprop="datePublished">2017-02-28</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/MAC/">MAC</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/02/28/Homebrew/">Homebrew</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>Homebrew官网：<a href="http://brew.sh/index_zh-cn.html" target="_blank" rel="external">http://brew.sh/index_zh-cn.html</a></p>
<p>Linux系统的通病是软件包依赖。当年安装一个软件包时，发现该软件包依赖于另外一个软件包。如果手动安装，你就得一个一个安装相关联的软件包。好在主流的发行版本的Linux系统都自带了解决方案，Red hat有yum，Ubuntu有apt-get。<br>MAC有类似的东西，就是Homebrew，是MAC OSX上的软件包管理工具，能在Mac中方便的安装和卸载软件。</p>
<p>Homebrew安装命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&quot;</div></pre></td></tr></table></figure></p>
<p>Homebrew常用命令行：<br>搜索软件：brew search 软件名，如brew search wget<br>安装软件：brew install 软件名，如brew install wget<br>卸载软件：brew remove 软件名，如brew remove wget</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://BreakMind.github.io/2017/02/28/Homebrew/" data-id="cizsoq1f40007ke6qo1exkxox" class="article-share-link">分享</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Block" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/02/28/Block/" class="article-date">
  <time datetime="2017-02-28T05:26:44.000Z" itemprop="datePublished">2017-02-28</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/IOS/">IOS</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/02/28/Block/">Block</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>在Objective-C中如何定义一个Block？</p>
<p>作为一个局部变量:<br>returnType (^blockName)(parameterTypes) = ^returnType(parameters) {…};</p>
<p>作为一个属性:<br>@property (nonatomic, copy, nullability) returnType (^blockName)(parameterTypes);</p>
<p>作为一个方法参数:</p>
<ul>
<li>(void)someMethodThatTakesABlock:(returnType (^nullability)(parameterTypes))blockName;<br>As an argument to a method call:</li>
</ul>
<p>[someObject someMethodThatTakesABlock:^returnType (parameters) {…}];</p>
<p>As a typedef:<br>typedef returnType (^TypeName)(parameterTypes);<br>TypeName blockName = ^returnType(parameters) {…};</p>
<h2 id="举个例子"><a href="#举个例子" class="headerlink" title="举个例子"></a>举个例子</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line">#import &lt;Foundation/Foundation.h&gt;</div><div class="line">#import &lt;pthread.h&gt;</div><div class="line"></div><div class="line">typedef void(^MY_BLOCK)(void);  // typedef Block</div><div class="line"></div><div class="line">@interface GHBlockTest : NSObject</div><div class="line">-(void)SetBlock:(MY_BLOCK)my_block; //Block作为参数</div><div class="line">-(MY_BLOCK)GetBlock;</div><div class="line">@end</div><div class="line"></div><div class="line">@interface GHBlockTest()</div><div class="line">@property(nonatomic, copy, nullable) MY_BLOCK myBlock;</div><div class="line">@end</div><div class="line"></div><div class="line">@implementation GHBlockTest</div><div class="line">@synthesize myBlock=_myBlock;</div><div class="line"></div><div class="line">-(void)SetBlock:(MY_BLOCK)my_block &#123;//Block作为值传入</div><div class="line">    _myBlock =my_block;</div><div class="line">&#125;</div><div class="line"></div><div class="line">-(void)showBlock&#123;</div><div class="line">    self.myBlock();</div><div class="line">&#125;</div><div class="line"></div><div class="line">-(MY_BLOCK)GetBlock&#123;</div><div class="line">    return self.myBlock; //作为值返回</div><div class="line">&#125;</div><div class="line">@end</div><div class="line"></div><div class="line"></div><div class="line">int main(int argc, char * argv[])</div><div class="line">&#123;</div><div class="line">    GHBlockTest * myBlockTest = [[GHBlockTest alloc] init];</div><div class="line">    __block NSInteger tmpThisYear; //仅用于演示Block内写入函数的局部变量，必须将此变量前增加 __block</div><div class="line">    [myBlockTest SetBlock:^&#123;</div><div class="line">        tmpThisYear = 2017;</div><div class="line">        NSLog(@&quot;Hello, %ld !&quot;, tmpThisYear);</div><div class="line">    &#125;];</div><div class="line">    [myBlockTest showBlock];</div><div class="line">    MY_BLOCK myNewBlock = [myBlockTest GetBlock]; //获取Block值</div><div class="line">    myNewBlock();</div><div class="line">    </div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="运行结果如下"><a href="#运行结果如下" class="headerlink" title="运行结果如下"></a>运行结果如下</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">2017-02-28 14:15:22.839019 NSThreadTest[28474:316728] Hello, 2017 !</div><div class="line">2017-02-28 14:15:22.839320 NSThreadTest[28474:316728] Hello, 2017 !</div><div class="line">Program ended with exit code: 0</div></pre></td></tr></table></figure>
<p>将Block嵌入到类中，可以直接get或者set类属性<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div></pre></td><td class="code"><pre><div class="line">#import &lt;Foundation/Foundation.h&gt;</div><div class="line">#import &lt;pthread.h&gt;</div><div class="line"></div><div class="line">typedef void(^MY_BLOCK)(void);      // typedef Block</div><div class="line"></div><div class="line">@interface GHBlockTest : NSObject</div><div class="line">-(void)SetBlock;                    //Block作为参数</div><div class="line">-(MY_BLOCK)GetBlock;</div><div class="line">@end</div><div class="line"></div><div class="line">@interface GHBlockTest()</div><div class="line">@property(nonatomic, copy, nullable) MY_BLOCK myBlock;</div><div class="line">@property(nonatomic, strong) NSString * helloString;</div><div class="line">@property(nonatomic, assign)NSInteger thisYear;</div><div class="line">@end</div><div class="line"></div><div class="line">@implementation GHBlockTest</div><div class="line">@synthesize myBlock=_myBlock;</div><div class="line">@synthesize helloString = _helloString;</div><div class="line">@synthesize thisYear = _thisYear;</div><div class="line"></div><div class="line">-(instancetype)init&#123;</div><div class="line">    self = [super init];</div><div class="line">    return self;</div><div class="line">&#125;</div><div class="line"></div><div class="line">-(void)SetBlock &#123;//Block作为值传入</div><div class="line">    _myBlock =^&#123;</div><div class="line">        _thisYear = 2017;			// 注意，在内嵌的Block里面，直接设置所在类的属性值。</div><div class="line">        _helloString = @&quot;Hello&quot;;	// 同上</div><div class="line">        NSLog(@&quot;%@, %ld !&quot;, _helloString,_thisYear);</div><div class="line">    &#125;;</div><div class="line">&#125;</div><div class="line"></div><div class="line">-(void)showBlock&#123;</div><div class="line">    self.myBlock();</div><div class="line">&#125;</div><div class="line"></div><div class="line">-(MY_BLOCK)GetBlock&#123;</div><div class="line">    return self.myBlock; //作为值返回</div><div class="line">&#125;</div><div class="line">@end</div><div class="line"></div><div class="line"></div><div class="line">int main(int argc, char * argv[])</div><div class="line">&#123;</div><div class="line">    GHBlockTest * myBlockTest = [[GHBlockTest alloc] init];</div><div class="line">    [myBlockTest SetBlock];</div><div class="line">    [myBlockTest showBlock];</div><div class="line">    </div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://BreakMind.github.io/2017/02/28/Block/" data-id="cizsoq1e50000ke6q8d3g69i3" class="article-share-link">分享</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-GCD" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/02/28/GCD/" class="article-date">
  <time datetime="2017-02-28T05:17:02.000Z" itemprop="datePublished">2017-02-28</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/IOS/">IOS</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/02/28/GCD/">GCD</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>异步：<br>当前线程可以开启多个线程执行任务，并且每个任务可以不按顺序执行</p>
<p>同步：<br>同步，本意就是“步调协调”，即协议当前线程按照一定的顺序依次执行。在多线程里，一些敏感的数据不允许被多个线程同时访问，此时使用同步技术访问（临界区，互斥量，信号量，事件），保证数据在任何一个时刻最多只有一个线程访问，以保证数据不被污染。</p>
<p>队列：<br>这里特指用于存储线程任务的队列数据结构。</p>
<p>一个进程可以有多个线程，一个线程可以有多个队列。<br>队列分为串行队列，并行队列。</p>
<p>全局队列：<br>    全局队列为并发队列。全局队列，供整个程序使用，在MRC的时候不需要释放。</p>
<p>主队列：<br>    主队列为串行队列。主要用于界面的更新（必须异步调用更新代码）。其他与界面更新无关的不要放在这里，否则容易造成界面阻塞。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://BreakMind.github.io/2017/02/28/GCD/" data-id="cizsoq1eo0003ke6qjzodc9s7" class="article-share-link">分享</a>
      
      
    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/">__('next') &raquo;</a>
  </nav>
</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">分类</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/IOS/">IOS</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/IOS-编写高质量代码/">IOS-编写高质量代码</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/MAC/">MAC</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/吐槽/">吐槽</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/鉴古/">鉴古</a></li></ul>
    </div>
  </div>


  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">归档</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/03/">三月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/02/">二月 2017</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2017/03/02/第5条：用枚举表示状态、选项、状态码/">第5条：用枚举表示状态、选项、状态码</a>
          </li>
        
          <li>
            <a href="/2017/03/02/第4条：多用类型常量，少用-define预处理指令/">第4条：多用类型常量，少用#define预处理指令</a>
          </li>
        
          <li>
            <a href="/2017/03/02/第3条：多用字面量语法，少用与之等价的方法/">第3条：多用字面量语法，少用与之等价的方法</a>
          </li>
        
          <li>
            <a href="/2017/03/02/第2条：在类的头文件中尽量少引入其他都文件/">第2条：在类的头文件中尽量少引入其他都文件</a>
          </li>
        
          <li>
            <a href="/2017/03/02/第1条：熟悉Objective-C/">第1条-熟悉Objective-C</a>
          </li>
        
      </ul>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">相关博客</h3>
    <div class="widget">
    <ul>
      <li><a href="http://ibireme.com" target="_blank">ibireme</a></li>
      <li><a href="http://blog.sunnyxx.com/" target="_blank">sunnyxx</a></li>
      <li><a href="http://github.ibireme.com/github/list/ios/" target="_blank">Github-iOS备忘</a></li>
      <li><a href="http://lysongzi.com/" target="_blank">lysongzZ_</a></li>
      <li><a href="http://blog.csdn.net/chenyufeng1991" target="_blank">乞力马扎罗的雪</a></li>
      <li><a href="http://www.shellsec.com/news/8114.html" target="_blank">BAT 面试指南</a></li>
      <li><a href="http://blog.csdn.net/yiyaaixuexi/" target="_blank">念茜</a></li>
      <li><a href="http://blog.txx.im/" target="_blank">TXX</a></li>
    </ul>
    </div>
  </div>


  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2017 BreakMind<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">主页</a>
  
    <a href="/archives" class="mobile-nav-link">归档</a>
  
    <a href="/" class="mobile-nav-link">个人简介</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>

  </div>
</body>
</html>