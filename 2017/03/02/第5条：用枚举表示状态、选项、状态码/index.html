<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>第5条：用枚举表示状态、选项、状态码 | Talk is cheap, show me the code.</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="由于Objective-C基于C语言，所以C语言有的功能它都有。其中之一就是枚举类型：enum。系统框架中频繁用到此类型，然而开发者容易忽视它。在以一系列常量来表示错误状态码或可组合的选项时，极宜使用枚举为其命名。由于C++11标注扩充了枚举的特性，所以最新版本系统框架使用了“强类型”（strong type）的枚举。没错，Objective-C也得益于C++11标准。枚举只是一种常量命名方式。某">
<meta property="og:type" content="article">
<meta property="og:title" content="第5条：用枚举表示状态、选项、状态码">
<meta property="og:url" content="http://BreakMind.github.io/2017/03/02/第5条：用枚举表示状态、选项、状态码/index.html">
<meta property="og:site_name" content="Talk is cheap, show me the code.">
<meta property="og:description" content="由于Objective-C基于C语言，所以C语言有的功能它都有。其中之一就是枚举类型：enum。系统框架中频繁用到此类型，然而开发者容易忽视它。在以一系列常量来表示错误状态码或可组合的选项时，极宜使用枚举为其命名。由于C++11标注扩充了枚举的特性，所以最新版本系统框架使用了“强类型”（strong type）的枚举。没错，Objective-C也得益于C++11标准。枚举只是一种常量命名方式。某">
<meta property="og:updated_time" content="2017-03-02T17:46:51.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="第5条：用枚举表示状态、选项、状态码">
<meta name="twitter:description" content="由于Objective-C基于C语言，所以C语言有的功能它都有。其中之一就是枚举类型：enum。系统框架中频繁用到此类型，然而开发者容易忽视它。在以一系列常量来表示错误状态码或可组合的选项时，极宜使用枚举为其命名。由于C++11标注扩充了枚举的特性，所以最新版本系统框架使用了“强类型”（strong type）的枚举。没错，Objective-C也得益于C++11标准。枚举只是一种常量命名方式。某">
  
    <link rel="alternate" href="/atom.xml" title="Talk is cheap, show me the code." type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
  

</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Talk is cheap, show me the code.</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">主页</a>
        
          <a class="main-nav-link" href="/archives">归档</a>
        
          <a class="main-nav-link" href="/">个人简介</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="搜索"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" results="0" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://BreakMind.github.io"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-第5条：用枚举表示状态、选项、状态码" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/03/02/第5条：用枚举表示状态、选项、状态码/" class="article-date">
  <time datetime="2017-03-02T15:50:32.000Z" itemprop="datePublished">2017-03-02</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/IOS-编写高质量代码/">IOS-编写高质量代码</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      第5条：用枚举表示状态、选项、状态码
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>由于Objective-C基于C语言，所以C语言有的功能它都有。其中之一就是枚举类型：enum。系统框架中频繁用到此类型，然而开发者容易忽视它。在以一系列常量来表示错误状态码或可组合的选项时，极宜使用枚举为其命名。由于C++11标注扩充了枚举的特性，所以最新版本系统框架使用了“强类型”（strong type）的枚举。没错，Objective-C也得益于C++11标准。<br>枚举只是一种常量命名方式。某个对象所经历的各种状态就可以定义为一个简单的枚举集（enumeration set）。比如说，可以用下列枚举表示“套接字链接”（socket connection）的状态：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">enum EOCConnectionState&#123;</div><div class="line">	EOCConnectionStateDisconnected,</div><div class="line">	EOCConnectionStateConnecting,</div><div class="line">	EOCConnectionStateConnected,</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>由于每种状态都用一个便于理解的值来表示，所以这样写出来的代码更易读懂。编译器会为枚举分配一个独有的编号，从0开始，每个枚举值递增为1.实现枚举所用的数据类型取决于编译器。不过其二进制位（bit）的个数必须能完全表示下枚举编号才行。在前例中，由于最大编号是2，所以使用1个字节的char类型即可。<br>然而定义枚举变量的方式却不太简洁，要依如下语法编写：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">enum EOCConnectionState state = EOCConnectionStateDisconnected;</div></pre></td></tr></table></figure></p>
<p>若是每次不用敲入enum而只需写EOCConnectionState就好了。要想这样做，则需使用typedef关键字重新定义枚举类型<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">enum EOCConnectionState&#123;</div><div class="line">	EOCConnectionStateDisconnected = 0,</div><div class="line">	EOCConnectionStateConnecting,</div><div class="line">	EOCConnectionStateConnected,</div><div class="line">&#125;;</div><div class="line">typedef enum EOCConnectionState EOCConnectionState;</div></pre></td></tr></table></figure></p>
<p>也可以简略写<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">typedef enum EOCConnectionState&#123;</div><div class="line">	EOCConnectionStateDisconnected = 0,</div><div class="line">	EOCConnectionStateConnecting,</div><div class="line">	EOCConnectionStateConnected,</div><div class="line">&#125;EOCConnectionState;</div></pre></td></tr></table></figure></p>
<p>现在可以用简写的EOCConnectionState来代替完整的enum EOCConnectionState了：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">EOCConnectionState state = EOCConnectionStateDisconnected;</div></pre></td></tr></table></figure></p>
<p>C++标准修订了枚举的某些特性。其中一项改动是：可以指明用何种“底层数据类型”（underlying type）来保存枚举类型的变量。这样做的好处是，可以向前声明枚举变量了。若不指定底层数据类型，则无法向前声明枚举类型，因为编译器不清楚底层数据类型的大小，所以在用到此枚举类型时，也就不知道究竟该给变量分配多少空间。<br>指定底层数据类型所用的语法是：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">enum EOCConnectionStateConnectionState : NSInteger &#123; /* ... */ &#125;;</div></pre></td></tr></table></figure></p>
<p>上面这行代码确保枚举的底层数据类型是NSInteger。也可以在向前声明时指定底层数据类型：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">enum EOCConnectionStateConnectionState : NSInteger;</div></pre></td></tr></table></figure></p>
<p>还可以不使用编译器所分配的序号，而是手工指定某个枚举成员所对应的值。语法如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">enum EOCConnectionStateConnectionState&#123;</div><div class="line">	EOCConnectionStateDisconnected = 1,</div><div class="line">	EOCConnectionStateConnecting,</div><div class="line">	EOCConnectionStateConnected,</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>上述代码把EOCConnectionStateDisconnected的值设为1，而不使用编译器所分配的0。如前所述，接下来几个枚举的值都会在上一个的基础上递增1。比如说，EOCConnectionStateConnected的值就是3。<br>还有一种情况应该使用枚举类型，那就是定义选项的时候。若这些选项可以彼此组合，则更应如此。只要枚举定义得对，个选项之间就可通过“按位或操作符”（bitwise OR operator）来组合。例如，IOS UI框架中有如下的枚举类型，用来表示某个视图应该如何在水平或垂直方向上调整大小：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">enum UIViewAutoresizing &#123;</div><div class="line">	UIViewAutoresizingNozne				= 0,</div><div class="line">	UIViewAutoresizingFlexibleLeftMargin		= 1 &lt;&lt; 0,</div><div class="line">	UIViewAutoresizingFlexibleWidth			= 1 &lt;&lt; 1,</div><div class="line">	UIViewAutoresizingFlexibleRightMargin		= 1 &lt;&lt; 2,</div><div class="line">	UIViewAutoresizingFlexibleTopMargin		= 1 &lt;&lt; 3,</div><div class="line">	UIViewAutoresizingFlexibleHeight		= 1 &lt;&lt; 4,</div><div class="line">	UIViewAutoresizingFlexibleBottomMargin		= 1 &lt;&lt; 5,</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>每个选项均可开启或禁用，使用上述方式来定义枚举值即可保证这一点，因为在每个枚举值所对应的二进制表示中，只有1个二进制位的值是1。用“按位或操作符”可组合多个选项，例如：UIViewAutoResizingFlexibleWidth | UIViewAutoresizingFlexibleHeight。图1-2列出了每个枚举成员的二进制值，并演示了刚才那两个枚举组合之后的值。用“按位与操作符”（bitwise AND operator）即可判断出是否已启用某个选项：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">enum UIViewAutoresizing resizing = </div><div class="line">	UIViewAutoresizingFlexibleWidth |</div><div class="line">	UIViewAutoresizingFlexibleHeight ;</div><div class="line"></div><div class="line">if (resizing &amp; UIViewAutoresizingFlexibleWidth) &#123;</div><div class="line">	// UIViewAutoresizingFlexibleWidht is set</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<pre><code>图1-2 每个枚举值的二进制表示，以及对其中两个枚举值执行按位或操作之后的二进制值
</code></pre><p>系统库中频繁使用这个办法。 IOS UI框架中的UIKit里还有个例子，用枚举值告诉系统视图所支持的设备显示方向。这个枚举类型叫做UIInterfaceOrientationMask，开发者需要实现一个名为supportedInterfaceOrientations的方法，将视图所支持的显示方向告诉系统：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">- (NSUInteger)supportedInterfaceOrientations &#123;</div><div class="line">	return UIInterfaceOrientationMaskPortrait | UIInterfaceOrientationMaskLandscapeLeft;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>Foundation框架中定义了一些辅助的宏，用这些红来定义枚举类型时，也可以指定用于保存枚举值得底层数据类型。这些宏具备向后兼容（backward compatibility）能力，如果目标平台的编译器支持新标注，那就使用新式语法，否则改用旧式鱍。这些宏是用#define预处理指令来定义的，其中一个用于定义像EOCConnectionState这种普通的枚举类型，另一个定义像UIViewAutoresizing这种包含一系列选项的枚举类型，其用法如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">typedef NS_ENUM(NSUInteger, EOCConnectionState) &#123;</div><div class="line">	EOCConnectionStateDisconnected,</div><div class="line">	EOCConnectionStateConnecting,</div><div class="line">	EOCConnectionStateConnected,</div><div class="line">&#125;;</div><div class="line"></div><div class="line">typedef NS_OPTIONS(NSUinteger, EOCPermittedDirection)&#123;</div><div class="line">	EOCPermittedDirectionUp		= 1 &lt;&lt; 0,</div><div class="line">	EOCPermittedDirectionDown	= 1 &lt;&lt; 1,</div><div class="line">	EOCPermittedDirectionLeft	= 1 &lt;&lt; 2,</div><div class="line">	EOCPermittedDirectionRight	= 1 &lt;&lt; 3,</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>这些宏的定义如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">#if (__cplusplus &amp;&amp; __cplusplus &gt;= 201103L &amp;&amp; (__has_extension(cxx_strong_enums) || _has_feature(objc_fixed_enum))</div><div class="line">	)||</div><div class="line">    (!__cplusplus &amp;&amp; __has_feature(objc_fixed_enum))</div><div class="line">    #define NS_ENUM(_type, _name)</div><div class="line">		enum _name : _type _name; enum _name : type</div><div class="line">    #if (__cplusplus)</div><div class="line">	#define NS_OPTIONS(_type, _name)</div><div class="line">		type _name; enum : _type</div><div class="line">    #else</div><div class="line">	#define NS_OPTIONS(_type, _name)</div><div class="line">		enum _name : _type _name; enum _name : type</div><div class="line">    #endif</div><div class="line">#else</div><div class="line">    #define NS_ENUM(_type, _name) _type _name; enum</div><div class="line">    #define NS_OPTIONS(_type, _name) _type _name; enum</div><div class="line">#endif</div></pre></td></tr></table></figure></p>
<p>由于需要分别处理不同情况，所以上述代码用多种方式来定义这两个宏。第一个#if用于判断编译器是否支持新式枚举。其中所用的布尔逻辑看上去相当复杂，不&gt;过其意思就是想判断编译器是否支持新的枚举特性。如果不支持，那么久用老式语法来定义枚举。<br>如果支持新特性，那么用NS_ENUM宏所定义的枚举类型展开后就是：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">typedef enum EOCConnectinState : NSUInteger EOCConnectionState;</div><div class="line">enum EOCConnectionState : NSUInteger &#123;</div><div class="line">	EOCConnectionStateDisconnected,</div><div class="line">	EOCConnectionStateConnecting,</div><div class="line">	EOCConnectionStateConnected,</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>根据是否要将代码按C++模式编译，NS_OPTIONS宏的定义方式也有所不同。如果不按C++编译，那么其展开方式就和NS_ENUM相同。若按C++编译，则展开后的代码略有不同。原因在于，用按位或运算来操作两个枚举值时，C++编译模式的处理办法与非C++模式不一样。而上面已经提到了，作为选项的枚举值经常需要用按位或运算来组合。在用或运算操作两个枚举值时，C++认为运算结果的数据类型应该是枚举的底层数据类型，也就是NSUInteger。而且C++不允许将这个底层类型“隐式转换”（implicit cast）为枚举类型本身。我们用EOCPermittedDirection来演示一下，假设按NS_ENUM方式将其展开：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">typedef enum EOCPermittedDirection : int EOCPermittedDirection;</div><div class="line">enum EOCPermittedDirection : int &#123;</div><div class="line">	EOCPermittedDirectionUp		= 1 &lt;&lt; 0,</div><div class="line">	EOCPermittedDirectionDown	= 1 &lt;&lt; 1,</div><div class="line">	EOCPermittedDirectionLeft	= 1 &lt;&lt; 2,</div><div class="line">	EOCPermittedDirectionRight	= 1 &lt;&lt; 3,</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>然后考虑下列代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">EOCPermittedDirection permittedDirections = EOCPermittedDirectionLeft | EOCPermittedDirectionUp;</div></pre></td></tr></table></figure></p>
<p>若编译器按C++模式编译（也可能是按Objective-C++模式编译），则会给出下列错误信息：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">error: cannot initilize a variable of type</div><div class="line">&apos;EOCPermittedDirection&apos; with an rvalue of type &apos;int&apos;</div></pre></td></tr></table></figure></p>
<p>如果想编译这行代码，就要将按位或操作的结果显式转换（explicit cast）为EOCPermittedDirection。所以，在C++模式下应该用另一种方式定义NS_OPTIONS宏，以便省去类型转换操作。鉴于此，凡是需要以按位或操作来组合的枚举都应使用NS_OPTIONS定义。若是枚举不需要互相组合，则应使用NS_ENUM来定义。</p>
<p>能够用到枚举的情况还有很多。前面已经提到，枚举可以表示选项与状态，然而还有许多东西也能用枚举来表示。比如状态码就是个好例子。可以把逻辑含义相似的一组状态码放入同一枚举集里，而不要用#define预处理指令或常量来定义。以枚举来表示样式（style）也很合宜。假如创建某个UI元素时可以使用不同的样式，那么在这种情况下就最应该把样式声明为枚举类型了。</p>
<p>最后再讲一种枚举的用法，就是在switch语句里。有时可以这样定义：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">typedef NS_ENUM(NSUInteger, EOCConnectionState)&#123;</div><div class="line">	EOCConnectionStateDisconnected,</div><div class="line">	EOCConnectionStateConnecting,</div><div class="line">	EOCConnectionStateConnected,</div><div class="line">&#125;;</div><div class="line"></div><div class="line">switch (_currentState) &#123;</div><div class="line">	EOCConnectionStateDisconnected:</div><div class="line">	// Handle disconnected state</div><div class="line">	break;</div><div class="line">	EOCConnectionStateConnecting:</div><div class="line">	// Handle connecting state</div><div class="line">	break;</div><div class="line">	EOCConnectionStateConnected:</div><div class="line">	// Handle connected state</div><div class="line">	break;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>我们总习惯在switch语句上加上default分支。然而，若是用枚举来定义状态机（State machine），则最好不要有default分支。这样的花，如果稍后又加了一种状态，那么编译器就会发出警告信息，提示新加入的状态并未在switch分支中处理。假如写上了default分支，那么它就会处理这个新状态，从而导致编译器不发警告信息。用NS_ENUM定义其他枚举类型时也要注意此问题。例如，在定义代表UI元素样式的枚举时，通常要确保switch语句能正确处理所有样式。</p>
<h2 id="要点"><a href="#要点" class="headerlink" title="要点"></a>要点</h2><p>应该用枚举来表示状态机的状态、传递给方法的选项以及状态码等值，给这些值起个易懂的名字。<br>如果把传递给某个方法的选项表示为枚举类型，而多个选项有可同时使用，那么久将各个选项值定义为2的幂，以便通过按位或操作将其组合起来。<br>用NS_ENUM于NS_OPTIONS洪来定义枚举类型，并指明其底层数据类型。这样做可以确保枚举是用开发者所选的底层数据类型实现出来的，而不会采用编译器所选的类型。<br>在处理枚举类型的switch语句中不要实现default分支。这样的话，加入新枚举之后，编译器就会提示开发者：switch语句并未处理所有枚举。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://BreakMind.github.io/2017/03/02/第5条：用枚举表示状态、选项、状态码/" data-id="cizsoq1g1000mke6qg0rla3xf" class="article-share-link">分享</a>
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
  
    <a href="/2017/03/02/第4条：多用类型常量，少用-define预处理指令/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">旧的</strong>
      <div class="article-nav-title">第4条：多用类型常量，少用#define预处理指令</div>
    </a>
  
</nav>

  
</article>


  <section id="comments">
    <!-- 多说评论框 start -->
    <div class="ds-thread" data-thread-key="post-第5条：用枚举表示状态、选项、状态码" data-title="第5条：用枚举表示状态、选项、状态码" data-url="http://BreakMind.github.io/2017/03/02/第5条：用枚举表示状态、选项、状态码/"></div>
    <!-- 多说评论框 end -->
    <!-- 多说公共JS代码 start (一个网页只需插入一次) -->
    <script type="text/javascript">
    var duoshuoQuery = {short_name:'breakmind'};
      (function() {
        var ds = document.createElement('script');
        ds.type = 'text/javascript';ds.async = true;
        ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
        ds.charset = 'UTF-8';
        (document.getElementsByTagName('head')[0] 
         || document.getElementsByTagName('body')[0]).appendChild(ds);
      })();
      </script>
    <!-- 多说公共JS代码 end -->
  </section>
  </section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">分类</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/IOS/">IOS</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/IOS-编写高质量代码/">IOS-编写高质量代码</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/MAC/">MAC</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/吐槽/">吐槽</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/鉴古/">鉴古</a></li></ul>
    </div>
  </div>


  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">归档</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/03/">三月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/02/">二月 2017</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2017/03/02/第5条：用枚举表示状态、选项、状态码/">第5条：用枚举表示状态、选项、状态码</a>
          </li>
        
          <li>
            <a href="/2017/03/02/第4条：多用类型常量，少用-define预处理指令/">第4条：多用类型常量，少用#define预处理指令</a>
          </li>
        
          <li>
            <a href="/2017/03/02/第3条：多用字面量语法，少用与之等价的方法/">第3条：多用字面量语法，少用与之等价的方法</a>
          </li>
        
          <li>
            <a href="/2017/03/02/第2条：在类的头文件中尽量少引入其他都文件/">第2条：在类的头文件中尽量少引入其他都文件</a>
          </li>
        
          <li>
            <a href="/2017/03/02/第1条：熟悉Objective-C/">第1条-熟悉Objective-C</a>
          </li>
        
      </ul>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">相关博客</h3>
    <div class="widget">
    <ul>
      <li><a href="http://ibireme.com" target="_blank">ibireme</a></li>
      <li><a href="http://blog.sunnyxx.com/" target="_blank">sunnyxx</a></li>
      <li><a href="http://github.ibireme.com/github/list/ios/" target="_blank">Github-iOS备忘</a></li>
      <li><a href="http://lysongzi.com/" target="_blank">lysongzZ_</a></li>
      <li><a href="http://blog.csdn.net/chenyufeng1991" target="_blank">乞力马扎罗的雪</a></li>
      <li><a href="http://www.shellsec.com/news/8114.html" target="_blank">BAT 面试指南</a></li>
      <li><a href="http://blog.csdn.net/yiyaaixuexi/" target="_blank">念茜</a></li>
      <li><a href="http://blog.txx.im/" target="_blank">TXX</a></li>
    </ul>
    </div>
  </div>


  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2017 BreakMind<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">主页</a>
  
    <a href="/archives" class="mobile-nav-link">归档</a>
  
    <a href="/" class="mobile-nav-link">个人简介</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>

  </div>
</body>
</html>